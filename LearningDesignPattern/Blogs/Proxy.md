# 代理模式

@(设计模式)

------------------

## 一、几点感想

1. 代理模式是常用的结构型设计模式之一，当无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，所访问的真实对象与代理对象需要实现相同的接口。这就是最基本的代理模式。
1. 代理模式：给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。
  Proxy Pattern: Provide a surrogate or placeholder for another object to control access to it.
1. 模式结构
  ![Alt text](./1508289617927.png)
   几个角色对象：
  （1）Subject（抽象主题角色）：它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。

```java
abstract class Subject
{
    public abstract void Request();
}
```

（2）Proxy（代理主题角色）：它**包含了对真实主题的引用**，从而可以在任何时候操作真实主题对象；在代理主题角色中提供一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中，客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作。

```java
class Proxy : Subject
{
    private RealSubject realSubject = new RealSubject(); //维持一个对真实主题对象的引用

    public void PreRequest()
    {
        ......
    }

    public override void Request()
    {
        PreRequest();
        realSubject.Request(); //调用真实主题对象的方法
         PostRequest();
    }

    public void PostRequest() 
    {
        ......
    }
}
```

（3）RealSubject（真实主题角色）：它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。

```java
class RealSubject : Subject
{
    public override void Request()
    {
        //业务方法具体实现代码
    }
}
```

1. 代理模式的拓展
  （1）远程代理：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又称为大使(Ambassador)。
  （2）虚拟代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。
  （3）保护代理：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。
  （4）缓冲代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。
  （5）智能引用代理：当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等。
